# Clear working environment
rm(list=ls())
# objects
n.iter = 10 # n (number) of iter (iterations). Used 1000, in the paper but 100 is good to see how it works
# libraries
library(lme4)
library(sjmisc)
library(sjPlot)
library(plyr)
library(MuMIn)
library(longFlight)
library(mgcv)
#data
load( file.path( PROJHOME , "Output" , "GPS-coh.rda"))
load( file.path( PROJHOME , "Output" , "ff-coh.rda"))
load( file.path( PROJHOME , "Output" , "dba-coh.rda"))
load( file.path( PROJHOME , "Output" , "nn-coh.rda"))
coh = dim(nn.coh)[1] # time of split
len = ncol(nn.coh)+1 # number of individuals plus a group level measure.
cols = c(rainbow(6),"black")
time = c(1:coh)/60/5
# group mean distance
y = (rowMeans(nn.coh))
# root transforms to try
roots = seq(1,1.4,0.1)
# object for r squared
r.sq = rep(NA,length(roots))
# loop to compare root transforms
for (  i in 1:length(roots)){
x = c(1:length(y))/5/60
mod2 = lm(y^(1/roots[i])~x)
r.sq[i] = (summary(mod2)$r.squared)
plot(y~x)
y2 = mod2$coefficients[1] + mod2$coefficients[2]*  x
lines(y2^roots[i]~x,col = "red")
}
mod2 = lm( lm(y^(1/ roots[which.max(r.sq)])~x) )
summary(mod2)
pdf( file.path(PROJHOME , "Figures" , "Group_dist2neighbour.pdf"))
y = bm_plotDS(matr = nn.coh, error = "SD", ylim = c(0,10), x = c(1,97), xlab = "Time (min)", ylab = "Distance to nearest neighbour (m)")
dev.off()
bm_plotDS(matr = nn.coh, error = "SD", ylim = c(0,10), x = c(1,97), xlab = "Time (min)", ylab = "Distance to nearest neighbour (m)")
acf(as.vector(nn.coh), lag.max = 1000)
AICs = matrix(NA,100,3)
for ( i in 1:n.iter){
mod= try( model2(nn.coh,400,scale = T))
AICs[i,] = mod[[3]]
}
whi.mi = which.min(colMeans(AICs))
print( c("simple linear model is best", "random intercepts only","random intercepts and slopes")[whi.mi])
CIs = matrix( NA, 100, 2)
for ( i in 1:n.iter){
mod = model2( nn.coh, 400, scale = T, specify.model = whi.mi)
CIs[i,] = mod[[2]]
}
# Sample length (sam.len)
sam.len = nrow ( nn.coh)/400
sam = sample( 1:nrow(nn.coh), sam.len)
nn = data.frame ( nn = as.vector(nn.coh[sam,]),
id = as.factor(rep (1: ncol(nn.coh), each = sam.len)),
time = rep(time[sam], ncol(nn.coh)))
#head(nn)
# fit glmer
m2 =lmer( data = nn, nn ~ time + (1+ time|id)  )
a = fixef(m2)
b = ranef(m2, condVar = T)
# Extract the variances of the random effects
qq <- attr(b[[1]], "postVar")
e=(sqrt(qq))
e=e[2,2,] #here we want to access the Petal.Weigth, which is stored in column 2 in b[[1]], that's why I use the [,2,2]
#calculate CI's
liminf=(b[[1]][2]+a[2])-(e*2)
mean_=(b[[1]][2]+a[2])
limsup=(b[[1]][2]+a[2])+(e*2)
#Plot betas and its errors
#make final plot
plot(nn$nn ~ nn$time, col = cols, las = 1, ylim = c(0,6), xlab = "Time (min)",
type = "n",
ylab = "Nearest neighbour distance (m)")
#and plot each random slope
for ( i in 1:6){
abline(a = as.numeric(b[[1]][i,1])+ as.numeric(a[1]), b= mean_$time[i], col = cols[i], lwd=2 )
}
#and general response
abline(a, lwd = 4)
pdf( file.path ( PROJHOME , "Figures" , "nn.mixed.plot.pdf"))
plot(nn$nn ~ nn$time, col = cols, las = 1, ylim = c(0,6), xlab = "Time (min)",
type = "n",
ylab = "Nearest neighbour distance (m)")
for ( i in 1:6){
abline(a = as.numeric(b[[1]][i,1])+ as.numeric(a[1]), b= mean_$time[i], col = cols[i], lwd=2 )
}
abline(a, lwd = 4)
dev.off()
acf( as.vector(ff.coh), lag.max =  200, ylim = c(0,0.4))
AICs = matrix(NA,100,3)
for ( i in 1:n.iter){
mod= try( model2(ff.coh,50,scale = T))
AICs[i,] = mod[[3]]
}
whi.mi = which.min(colMeans(AICs))
print( c("simple linear model is best", "random intercepts only","random intercepts and slopes")[whi.mi])
CIs = matrix( NA, 100, 2)
for ( i in 1:n.iter){
mod = model2( ff.coh, 50, scale = T, specify.model = whi.mi)
CIs[i,] = mod[[2]]
}
# Sample length (sam.len)
ind.len = nrow ( ff.coh)
sam.len = ind.len/50
sam = sample( 1:ind.len, sam.len)
ff = data.frame( ff = as.vector(ff.coh[sam,]),
id = rep(1:6, each = length(sam)),
time = rep(sam,6)/60)
fit <- lmer(ff ~ time + (1|id), data = ff)
a = fixef(fit)
b = ranef(fit, condVar = T)
#make final plot
{plot(ff$ff ~ ff$time, col = as.numeric(ff$id)+1, las = 1, ylim = c(6.6,7.3), xlab = "Time (min)",
ylab = "Flap frequency (Hz)", type = "n")
#and plot each random slope
for ( i in 1:6){
abline(a = as.numeric(b[[1]][i,1])+ as.numeric(a[1]), b= a[2], col = cols[i], lwd=2 )
}
}
#and general response
abline(a, lwd = 4)
if( ! file.exists( file.path(PROJHOME , "Figures" , "ff.pdf"))){
pdf( file.path ( PROJHOME , "Figures", "ff.pdf"))
{plot(ff$ff ~ ff$time, col = as.numeric(ff$id)+1, las = 1, ylim = c(6.6,7.3), xlab = "Time (min)",
ylab = "Flap frequency (Hz)", type = "n")
for ( i in 1:6){
abline(a = as.numeric(b[[1]][i,1])+ as.numeric(a[1]), b= a[2], col = cols[i], lwd=2 )
}
}
abline(a, lwd = 4)
dev.off()
}
